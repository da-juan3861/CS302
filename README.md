Software Development Life Cycle

The software development life cycle (SDLC) consists of several phases. Read this section to explore the software life cycle and these main phases.
Introduction

The software-development life-cycle (SDLC) is used to facilitate the development of a large software product in a systematic, well-defined, and cost-effective way. An information system goes through a series of phases from conception to implementation. This process is called the Software-Development Life-Cycle. Various reasons for using a life-cycle model include:

    Helps to understand the entire process 
    Enforces a structured approach to development 
    Enables planning of resources in advance 
    Enables subsequent controls of them 
    Aids management to track progress of the system


Phases of SDLC 

The SDLC consists of several phases and these phases need to be identified along with defining the entry and exit criteria for every phase. A phase can begin only when the corresponding phase-entry criteria are satisfied. Similarly, a phase can be considered to be complete only when the corresponding exit criteria are satisfied. If there is no clear indication of the entry and exit for every phase, it becomes very difficult to track the progress of the project. The SDLC can be divided into 5-9 phases, i.e., it must have a minimum of five phases and a maximum of nine phases. On average it has seven or eight phases. These are:

    Project initiation and planning/Recognition of need/Preliminary investigation
    Project identification and selection/Feasibility study 
    Project analysis 
    System design 
    Coding 
    Testing 
    Implementation 
    Maintenance


Project initiation and planning/Recognition of need/Preliminary investigation

Recognition of need is nothing but the problem definition. It is the decision about problems in the existing system and the impetus for system change. The first stage of any project or SDLC is called the preliminary investigation. It is a brief investigation of the system under consideration. At this stage the need for changes in the existing system are identified and shortcomings of the existing system are detected.


Feasibility Study 

A feasibility study is a preliminary study which investigates the information needs of prospective users and determines the resource requirements, costs, benefits, and feasibility of a proposed project. The goal of feasibility studies is to evaluate alternative systems and to propose the most feasible and desirable systems for development.


System Analysis 

Project analysis is a detailed study of the various operations performed by a system and their relationships within and outside the system. Detailed investigation should be conducted with personnel closely involved with the area under investigation, according to the precise terms of reference arising out of the initial study reports.

The tasks to be carried out should be clearly defined such as: 

    Examine and document the relevant aspects of the existing system, its shortcomings and problems. 
    Analyze the findings and record the results. 
    Define and document in an outline the proposed system. 
    Test the proposed design against the known facts. 
    Produce a detailed report to support the proposals. 
    Estimate the resources required to design and implement the system.

The objectives at this stage are to provide solutions to stated problems, usually in the form of specifications to meet the users' requirements and to make recommendations for a new computer-based system. Analysis is an iterative and progressive process, examining information flows and evaluating various alternative design solutions until a preferred solution is available. This is documented as the system proposal.


System Design 

System design is the most creative and challenging phase of the SDLC. The term design describes the final system and process by which it is developed. This phase is a very important phase of the life-cycle. The design process translates requirements into a representation of the software that can be assessed for quality before coding begins. The design is documented and becomes part of the software configuration.


Coding 

The goal of the coding phase is to translate the design of the system into code in a given programming language. In this phase the aim is to implement the design in the best possible manner. This phase affects both testing and maintenance phases. Well-written code can reduce the testing and maintenance effort. Hence, during coding the focus is on developing programs that are easy to read and understand and not simply on developing programs that are simple to write.


Testing 

Testing is the major quality-control measure used during software development. Its basic function is to detect errors in the software. The goal of testing is to uncover requirement, design, and coding errors in the program. Testing is an extremely critical and time-consuming activity. It requires proper planning of the overall testing process.

During the testing of the unit, the specified test cases are executed and the actual results are compared with the expected output. The final output of the testing phase is the test report and the error report, or a set of such reports (one for each unit tested).


Implementation 

The implementation phase is less creative than system design. It is mainly concerned with user training, site selection, and preparation and file conversion. Once the system has been designed, it is ready for implementation. Implementation is concerned with those tasks leading immediately to a fully operational system. It involves programmers, users, and operations management, but its planning and timing is a prime function of a systems analyst. It includes the final testing of the complete system to user satisfaction, and supervision of initial operation of the system. Implementation of the system also includes providing security to the system.


Maintenance 

Maintenance is an important part of the SDLC. If there is any error to correct or change then it is done in the maintenance phase. Maintenance of software is also a very necessary aspect related to software development. Many times maintenance may consume more time than the time consumed in the development. Also, the cost of maintenance varies from 50% to 80% of the total development cost. Maintenance may be classified as:

Corrective Maintenance. Corrective maintenance means repairing processing or performance failures or making changes because of previously uncorrected problems. 

Adaptive Maintenance. Adaptive maintenance means changing the program function. This is done to adapt to the external environment change, such as new government regulations. For example, the current system was designed so that it calculates taxes on profits after deducting the dividend on equity shares. The government has issued orders now to include the dividend in the company profit for tax calculation. This function needs to be changed to adapt to the new system.

Perfective Maintenance. Perfective maintenance means enhancing the performance or modifying the programs to respond to the user's additional or changing needs. It involves changes that the client thinks will improve the effectiveness of the product, such as additional functionality or decreased response time.As maintenance is very costly and very essential, efforts have been done to reduce its costs. One way to reduce the costs is through maintenance management and software modification audits. Software modification consists of program rewriting and system-level-upgrading. 

Preventive Maintenance. Preventive maintenance is the process by which we prevent our system from being obsolete. Preventive maintenance involves the concept of re-engineering and reverse engineering in which an old system with an old technology is re-engineered using new technology. This maintenance prevents the system from dying out.


Conclusion 

When you build a software system, it's important to go through a series of steps. This is a road map that helps in creating a timely and high-quality result. This is a systematic approach in which software engineering is emphasizing a number of phases. 
